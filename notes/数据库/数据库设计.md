## 数据库设计

### 一、简介

一般情况下数据量不大的表不会进行分库分表操作，如果某些表每天会产生大量的数据，以至于一张表无法搞定，那么就需要想办法将数据放到多个地方，目前比较普遍的方案有三个：

1. 分区
2. 分库分表
3. NoSQL/NewSQL

说明：NoSQL比较具有代表性的是MongoDB、ElasticSearch；NewSQL比较具有代表性的是TiDB。

### 二、分库分表

#### 1）分库分表的思路

分库分表的第一步也是最重要的一步是选取sharding column，sharding column选择的好坏将直接决定整个分库分表方案最终是否成功。而sharding column的选取跟业务强相关，所以选择sharding column的方法最主要分析API流量，优先考虑流量大的API，将流量比较大的API对应的SQL提取出来，将这些SQL共同的条件作为sharding column。例如一般的系统都是对用户提供服务，这些API对应的SQL都有条件用户ID，那么，用户ID就是非常好的sharding column。

分库分表的几种处理思路：

1. 只选取一个sharding column进行分库分表 ；
2. 多个sharding column多个分库分表；
3. sharding column分库分表 + es；

例如：

订单表

order_id	user_id	merchant_code	order_amount	order_time	remark

这里选择三个column作为三个独立的sharding column，即：order_id，user_id，merchant_code。user_id和merchant_id是买家ID和卖家ID，因为订单系统中买家和卖家的查询流量都比较大，并且对实时性要求都很高。而根据order_id进行查询的也比较多。

**冗余全量**的情况下，每个sharding列对应的表的数据都是全量的，这样做的优点是不需要二次查询，性能更好，缺点是比较浪费存储空间：

**order_id**	user_id	merchant_code	order_amount	order_time	remark	(t_order表)

**user_id**	order_id	merchant_code	order_amount	order_time	remark	(t_user_order表)

**merchant_code**	order_id	user_id	order_amount	order_time	remark	(t_merchant_order表)

**冗余关系索引表**的情况下，只有一个sharding column的分库分表的数据是全量的，其他分库分表只是与这个sharding column的关系表，只有做的优点是节省空间，缺点是除了第一个sharding column的查询，其他sharding column的查询都需要二次查询，这三张表的关系如下所示：

**order_id**	user_id	merchant_code	order_amount	order_time	remark	(t_order表)

**user_id**	order_id	(t_user_order表)

**merchant_code**	order_id	(t_merchant_order表)

**冗余全量表 PK 冗余关系表**

1. 速度对比：冗余全量表速度更快，冗余关系表需要二次查询，即使有引入缓存，还是多一次网络开销；
2. 存储成本：冗余全量表需要几倍于冗余关系表的存储成本；
3. 维护代价：冗余全量表维护代价更大，涉及到数据变更时，多张表都要进行修改。

#### 2）垂直拆分

垂直拆分是指按照业务将表进行分类，分布到不同的数据库上面，这样就将数据分摊到了不同的库上了。

优点：

1. 拆分后业务清晰，拆分规则明确
2. 系统之间整合或扩展容易
3. 数据维护简单
4. 方便做微服务

缺点：

1. 部分业务表无法join，只能通过接口方式解决，提高了系统复杂度
2. 受每种业务不同的限制存在单库性能瓶颈，不利于数据扩展和性能提升
3. 事物处理复杂

#### 3）水平拆分

垂直拆分后遇到的性能瓶颈，可以使用水平拆分。相对于垂直拆分的区别是：垂直拆分是把不同的表拆到不同的数据库中，而水平拆分是把同一个表拆分到不同的数据库中。

相对于垂直拆分，水平拆分不是将表的数据做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中 的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库中，主要有分表，分库两种模式。

优点：

1. 不存在单库大数据，高并发的性能瓶颈
2. 对应用透明，应用端改造较少
3. 按照合理拆分规则拆分，join操作基本避免跨库
4. 提高了系统的稳定性跟负载能力

缺点：

1. 拆分规则难以抽象
2. 分片事务一致性难以解决
3. 数据多次扩展难度跟维护量极大
4. 跨库join性能较差

#### 4）拆分的难点

两种方式共同的缺点：

1. 引入分布式事务的问题
2. 跨节点Join 的问题
3. 跨节点合并排序分页问题

针对数据源管理，目前主要有两种思路：

1. 客户端模式，在每个应用程序模块中配置管理自己需要的一个（或者多个）数据源，直接访问各个 数据库，在模块内完成数据的整合。 
   优点：相对简单，无性能损耗。   
   缺点：不够通用，数据库连接的处理复杂，对业务不够透明，处理复杂。

2. 通过中间代理层来统一管理所有的数据源，后端数据库集群对前端应用程序透明

   优点：通用，对应用透明，改造少

   缺点：实现难度大，有二次转发性能损失

#### 5）拆分原则

1. 尽量不拆分，架构是进化而来，不是一蹴而就
2. 最大可能的找到最合适的切分维度
3. 由于数据库中间件对数据Join 实现的优劣难以把握，而且实现高性能难度极大，业务读取  尽量少使用多表Join -尽量通过数据冗余，分组避免数据垮库多表join
4. 尽量避免分布式事务
5. 单表拆分到数据1000万以内

#### 6）拆分方案

1. 范围
2. 枚举
3. 时间
4. 取模
5. 哈希
6. 指定 ...

### 三、表设计准则

#### 1）字段的原则性

> 包证每列的原则性，不可分解，意思表达清楚，不能含糊，高度概括字段的含义，能用一个字段表达清楚的绝不使用第二个字段，必须要使用两个字段表达清楚的绝不能使用一个字段。

#### 2）主键设计

> 主键不要与业务逻辑有所关联，最好是毫无意义的一串独立不重复的数字，常见的比如UUID或者将主键设置为Auto_increment。

#### 3）字段使用次数

> 对于频繁修改的字段（一般是指状态类字段）最好用独立的数字或者单个字母去表示，不用使用汉字或长字符的英文。

#### 4）字段长度

> 建表的时候，字段长度尽量要比实际业务的字段大3-5个字段左右（考虑到合理性和伸缩性），最好是2的n次方幂值。不能建比实际业务太大的字段长度（比如订单id如果考虑要业务增长的话，一定要使用Long型，对应的数据库的数据类型是bigint），这是因为如果字段长度过大，在进行查询的时候索引在B-Tree树上遍历会越耗费时间，从而查询的时间会越久；但是绝对不能建小，否则mysql数据会报错，程序会抛出异常。

#### 5）关于外键

> 尽量不要建立外键，保证每个表的独立性。如果非得保持一定的关系，最好是通过id进行关联。

#### 6）动静分离

> 最好做好静态表和动态表的分离。
>
> 静态表：存储着一些固定不变的资源，比如城市/地区名/国家(静态表一定要使用缓存)。
>
> 动态表：一些频繁修改的表。

#### 7）关于code值

> 使用数字码或者字母去代替实际的名字，也就是尽量把name转换为code，因为name可能会变（万一变化就会查询出多条数据，从而抛出错误），但是code一般是不会变化的；另一方面，code值存储的字符较少，也能减少数据库的存储空间的压力。

#### 8）关于Null值

> 尽量不要有null值，有null值的话，数据库在进行索引的时候查询的时间更久，从而浪费更多的时间！可以在建表的时候设置一个默认值。

#### 9）关于引擎的选择

> innodb与myisam，myisam的实际查询速度要比innodb快，因为它不扫描全表，但是myisam不支持事务，没办法保证数据的ACID。选择哪个这就要看自己对于效率和数据稳定性方面的实际业务的取舍了

#### 10）资源存储

> 数据库不要存储任何资源文件，比如照片/视频/网站等，可以用文件路径/外链用来代替，这样可以在程序中通过路径，链接等来进行索引。

#### 11）与主键相关

> 根据数据库设计三大范式，尽量保证列数据和主键直接相关而不是间接相关

#### 12）关系映射

> 多对一或者一对多的关系,关联一张表最好通过id去建立关系，而不是去做重复数据，这样做最大的好处就是中间的关系表比较清楚明白。

#### 13）预留字段

> 在设计一张表的时候应该预制一个空白字段，用于以后的扩展，因为你也不是确定这张表以后不会扩展

#### 14）留下单一字段确定是否可用

> 通过一个单一字段去控制表是否可用，比如通常起名为isVaild，预制的含义为0为有效，1为无效，这样便于以后我们去剔除数据或者重整数据，使其成为boolean性质的数据 更加便于我们去操控。

#### 15）删除字段

> 数据库是禁止使用delete命令的,一般都不会真正删除数据，都是采用改状态的方式，设置state字段，通过修改状态赋予它是否有效的逻辑含义

### 四、触发器

Oracle创建触发器的一般语法：

```sql
CREATE [OR REPLACE] TRIGGER 触发器名
{BEFORE|AFTER}
{INSERT|DELETE|UPDATE[OF column[,column]]}
[OR {INSERT|DELETE|UPDATE[OF column[,column]]}]
ON [schema.]table_name | [schema.]view_name
[REFERENCING{OLD [AS]old | NEW [AS]new|PARENT as parent}]
[FOR EACH ROW]
[WHERE(条件)]
DECLARE
声明部分
BEGIN
主体部分
END;
```

触发器使用规则和限制：

1. Create Trigger语句必须是批处理中的第一个语句
2. 在默认情况下，创建触发器的权限将分配给数据表的所有者，且不能转给其他用户
3. 触发器是数据库对象，其名称必须遵循标识符的命名规则
4. 虽然触发器可以引用当前数据库以外的对象，但是只能在当前数据库中创建触发器
5. 虽然不能在临时数据表上创建触发器，但是触发器可以引用临时数据表
6. 不能在系统数据表创建触发器，也不可以引用系统数据库
7. 在包含使用delete或updata操作定义中，不能定义instead of和instead of update触发器
8. TRUNCATE TABLE语句不会引发Delete触发器，因为该语句没有被记入日志
9. Writetext语句不会引发insert或update触发器

### 五、存储过程

创建存储过程的语法：

```sql
CREATE [OR REPLACE] PROCEDURE 存储过程名（参数名1 参数类型1，参数名2 参数类型2，...）
BEGIN
代码块
END
```

存储过程的优缺点：

优点：

1. 速度快。存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL 语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度
2. 写程序简单。采用存储过程调用类，调用任何存储过程都只要1-2行代码
3. 升级、维护方便。存储过程会使得维护起来更加方便，因为通常修改一个存储过程要比在一个已经发布的组件中修改SQL语句更加方便
4. 能够缓解网络带宽。因为可以批量执行SQL语句而不是从客户端发送超负载的请求。尤其对于较为复杂的逻辑，减少了网络流量之间的消耗
5. 可保证数据的安全性和完整性。通过存储过程可以使没有权限的用户在控制之下间接地存取数据库，从而保证数据的安全。通过存储过程可以使相关的动作在一起发生，从而可以维护数据库的完整性

缺点：

1. 可移植性差。由于存储过程将应用程序绑定到 SQL Server，因此使用存储过程封装业务逻辑将限制应用程序的可移植性。如果应用程序的可移植性在您的环境中非常重要，则将业务逻辑封装在不特定于 RDBMS 的中间层中可能是一个更佳的选择
2. 代码可读性差,相当难维护
3. 不支持群集
4. 大量采用存储过程进行业务逻辑的开发致命的缺点是很多存储过程不支持面向对象的设计，无法采用面向对象的方式将业务逻辑进行封装，从而无法形成通用的可支持复用的业务逻辑框架
5. 如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦

存储过程的使用原则：

1. 当一个业务同时对多个表进行处理的时候采用存储过程比较合适
2. 复杂的数据处理用存储过程比较合适，如有些报表处理
3. 多条件多表联合查询，并做分页处理，用存储过程也比较适合
4. 使用存储过程，等需求变动，需要维护的时候，麻烦就来了。不应该大规模使用
5. 适当的使用存储过程，能够提高我们SQL查询的性能，以便于提高我们的工作效率

### 六、开发配置

